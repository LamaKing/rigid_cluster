%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{MD\_rigid}
\date{May 01, 2023}
\release{0.1}
\author{Andrea Silva}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}




\sphinxAtStartPar
Compute the interlocking potential between a periodic substrate and a finite\sphinxhyphen{}size adsorbate, in the rigid approximation.
The adsorbate is treated as a rigid body at a given orientation \$theta\$ and center of mass (CM) position \$x\_mathrm\{cm\}, {\color{red}\bfseries{}y\_}mathrm\{cm\}\$


\chapter{Substrate}
\label{\detokenize{index:substrate}}
\sphinxAtStartPar
The substrate is defined as a periodic function resulting from either a monocromaitc superposition of plane waves or a potential well of a given shape repeated in space.
The functions handling the substrate creation are in \sphinxcode{\sphinxupquote{tool\_create\_substrate.py}}.

\sphinxAtStartPar
For a plane wave superposition, the substrate is defined by a suitable set of wave vectors, where the number of vectors defines the symmetry and length of vectors defines the spacing {[}1{]}.

\sphinxAtStartPar
For a lattice of wells, the substrate is defined by the shape parameters of the well and the lattice vectors {[}2\sphinxhyphen{}5{]}. This substrate can be decorated with a lattice basis.

\sphinxAtStartPar
The parameters are specified in a JSON file.
See Example/0\sphinxhyphen{}Substrate\_types.ipynb for details.


\chapter{Cluster}
\label{\detokenize{index:cluster}}
\sphinxAtStartPar
The cluster is defined as a collection of points (optionally decorate with a basis) belonging to a given lattice.
For convenience, there are functions returning clusters in regular shapses, e.g. rectangles, hexagons, circles, etc.
Using the \sphinxhref{https://shapely.readthedocs.io/en/stable/}{Shapely package}, clusters of arbitrary shapes (e.g. imaged in experiments) can be created.
The functions handling the substrate creation are in \sphinxcode{\sphinxupquote{tool\_create\_substrate.py}}.

\sphinxAtStartPar
See example/1\sphinxhyphen{}Cluster\_creation.ipynb for details.


\chapter{Static Maps}
\label{\detokenize{index:static-maps}}
\sphinxAtStartPar
See example/2\sphinxhyphen{}Cluster\_on\_substrate.ipynb for details on the following functions.


\section{Translations}
\label{\detokenize{index:translations}}
\sphinxAtStartPar
To explore the energy landscape of an adsorbate over a substrate as a function of the CM at fixed orientation, see \sphinxcode{\sphinxupquote{static\_trasl\_map.py}}


\section{Rotations}
\label{\detokenize{index:rotations}}
\sphinxAtStartPar
To explore the energy landscape of an adsorbate over a substrate as a function of the imposed rotation \$theta\$, at fixed CM, see \sphinxcode{\sphinxupquote{static\_roto\_map.py}}


\section{Roto\sphinxhyphen{}translations}
\label{\detokenize{index:roto-translations}}
\sphinxAtStartPar
To search for the global minimum of an adosrbate, one needs to combine rotations and translation, and locate the energy minimum in the \$({\color{red}\bfseries{}x\_}mathrm\{cm\}, {\color{red}\bfseries{}y\_}mathrm\{cm\}, theta)\$ space. See \sphinxcode{\sphinxupquote{static\_rototrasl\_map.py}} for details.


\chapter{Dynamics Maps}
\label{\detokenize{index:dynamics-maps}}
\sphinxAtStartPar
To go beyond rigid maps, there are two essential tools: compute the minimum energy path between two minimum or perform a molecular dynamics calculation under given translational and rotational drives \$(F\_x, F\_y, tau)\$.


\section{Barrier finding}
\label{\detokenize{index:barrier-finding}}
\sphinxAtStartPar
The barrier between two points in the configurational space \$({\color{red}\bfseries{}x\_}mathrm\{cm\}, {\color{red}\bfseries{}y\_}mathrm\{cm\}) at fixed orientation can be estimated be the string algorithm {[}6{]}, similar to the NEB methods.
The ideal can be summarised like this: imagine the potential energy to be a hill landscape. Place a string between two points of the landscape and let it relax. The string would relax downhill until the gradient on the string vanishes, i.e. the string layes on the pass between the valleys and below the peaks.

\sphinxAtStartPar
See example/3\sphinxhyphen{}Barrier\_from\_stirng.ipynb


\section{Molecular dynamics}
\label{\detokenize{index:molecular-dynamics}}
\sphinxAtStartPar
The script \sphinxcode{\sphinxupquote{MD\_rigid\_rototrasl.py}} solve the equation of motion for the center of mass and orientation of the cluster in the overdamped regime (no interial term).

\sphinxAtStartPar
See example/molecular\_dynamics for an example of a system depinning under a constant force and torque.


\subsection{Equations of motion}
\label{\detokenize{index:equations-of-motion}}
\sphinxAtStartPar
In the overdamped limit, the equation of motion are the following first order equations:

\sphinxAtStartPar
\$\$ gamma\_\{t\} frac\{dmathbf\{r\}\}\{dt\} = (mathbf\{F\}\_\{ext\} \sphinxhyphen{} nabla U) \$\$

\sphinxAtStartPar
\$\$ gamma\_\{r\} frac\{dtheta\}\{dt\} = (tau\_\{ext\} \sphinxhyphen{} frac\{dU\}\{dtheta\}) \$\$

\sphinxAtStartPar
The dissipation constants of the CM for a cluster of \$N\$ particles are linked the “particle\sphinxhyphen{}like” damping constant \$gamma\$ by
\$gamma\_t = N gamma\$
and
\$gamma\_r = gamma sum\_i r\_i\textasciicircum{}2 \$, where \$r\_i\$ is the position of the \$i\$\sphinxhyphen{}th particle with respect to the center of mass.

\sphinxAtStartPar
In this picture energy is not conserved (fully dissipated in the Langevin bath between successive timesteps) and the value of the dissipation constant \$gamma\$ effectively sets how quickly the time flows.
Thus by lowering \$gamma\$ one can “speed up” the simulations and match timescales similar to experiments.


\chapter{Units}
\label{\detokenize{index:units}}
\sphinxAtStartPar
The model can be ragarded as adimensional.

\sphinxAtStartPar
A coherent set of units useful to compare with experimental colloidal system is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
energy in zJ

\item {} 
\sphinxAtStartPar
length in \$mumathrm\{m\}\$

\item {} 
\sphinxAtStartPar
mass in fKg

\end{itemize}

\sphinxAtStartPar
From which follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
force in fN

\item {} 
\sphinxAtStartPar
torque in fN \$cdot mu mathrm\{m\}\$

\item {} 
\sphinxAtStartPar
time in ms

\item {} 
\sphinxAtStartPar
translational damping constant \$gamma\$ in fKg/ms

\end{itemize}


\chapter{References}
\label{\detokenize{index:references}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Vanossi, Andrea, Nicola Manini, and Erio Tosatti. “Static and Dynamic Friction in Sliding Colloidal Monolayers.” Proceedings of the National Academy of Sciences 109, no. 41 (October 9, 2012): 16429\textendash{}33. \sphinxurl{https://doi.org/10.1073/pnas.1213930109}.

\item {} 
\sphinxAtStartPar
Panizon, Emanuele, Andrea Silva, Xin Cao, Jin Wang, Clemens Bechinger, Andrea Vanossi, Erio Tosatti, and Nicola Manini. “Frictionless Nanohighways on Crystalline Surfaces.” Nanoscale 15, no. 3 (2023): 1299\textendash{}1316. \sphinxurl{https://doi.org/10.1039/D2NR04532J}.

\item {} 
\sphinxAtStartPar
Cao, Xin, Andrea Silva, Emanuele Panizon, Andrea Vanossi, Nicola Manini, Erio Tosatti, and Clemens Bechinger. “Moiré\sphinxhyphen{}Pattern Evolution Couples Rotational and Translational Friction at Crystalline Interfaces.” Physical Review X 12, no. 2 (June 15, 2022): 021059. \sphinxurl{https://doi.org/10.1103/PhysRevX.12.021059}.

\item {} 
\sphinxAtStartPar
Cao, Xin, Emanuele Panizon, Andrea Vanossi, Nicola Manini, and Clemens Bechinger. “Orientational and Directional Locking of Colloidal Clusters Driven across Periodic Surfaces.” Nature Physics 15, no. 8 (August 2019): 776\textendash{}80. \sphinxurl{https://doi.org/10.1038/s41567-019-0515-7}.

\item {} 
\sphinxAtStartPar
Cao, Xin, Emanuele Panizon, Andrea Vanossi, Nicola Manini, Erio Tosatti, and Clemens Bechinger. “Pervasive Orientational and Directional Locking at Geometrically Heterogeneous Sliding Interfaces.” Physical Review E 103, no. 1 (January 13, 2021): 012606. \sphinxurl{https://doi.org/10.1103/PhysRevE.103.012606}.

\item {} 
\sphinxAtStartPar
E, Weinan, Weiqing Ren, and Eric Vanden\sphinxhyphen{}Eijnden. “Simplified and Improved String Method for Computing the Minimum Energy Paths in Barrier\sphinxhyphen{}Crossing Events.” The Journal of Chemical Physics 126, no. 16 (April 28, 2007): 164103. \sphinxurl{https://doi.org/10.1063/1.2720838}.

\end{enumerate}


\chapter{Contents}
\label{\detokenize{index:contents}}
\sphinxstepscope


\section{Modules}
\label{\detokenize{modules:modules}}\label{\detokenize{modules::doc}}

\subsection{Tools}
\label{\detokenize{modules:tools}}
\sphinxstepscope


\subsubsection{Substrate}
\label{\detokenize{tool_create_substrate:module-tool_create_substrate}}\label{\detokenize{tool_create_substrate:substrate}}\label{\detokenize{tool_create_substrate::doc}}\index{module@\spxentry{module}!tool\_create\_substrate@\spxentry{tool\_create\_substrate}}\index{tool\_create\_substrate@\spxentry{tool\_create\_substrate}!module@\spxentry{module}}\index{calc\_en\_gaussian() (in module tool\_create\_substrate)@\spxentry{calc\_en\_gaussian()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_en_gaussian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_en\_gaussian}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{sigma}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on CM.

\sphinxAtStartPar
See corresponding particle function for details on parameters.

\sphinxAtStartPar
Return total energy (scalar) force (2d vector) torque (scalar).

\end{fulllineitems}

\index{calc\_en\_sin() (in module tool\_create\_substrate)@\spxentry{calc\_en\_sin()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_en_sin}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_en\_sin}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{ks}}, \emph{\DUrole{n}{epsilon}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on CM.

\sphinxAtStartPar
Substrate energy is modelled as sum of plane waves defined by the reciprocal vecotrs ks.

\sphinxAtStartPar
See corresponding particle function for details on parameters.

\sphinxAtStartPar
Return total energy (scalar) force (2d vector) torque (scalar).

\end{fulllineitems}

\index{calc\_en\_sin\_tri() (in module tool\_create\_substrate)@\spxentry{calc\_en\_sin\_tri()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_en_sin_tri}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_en\_sin\_tri}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on CM.

\sphinxAtStartPar
!!! Coefficients are for triangular lattice only !!!
Substrate energy is modelled as sum of three plane waves.

\end{fulllineitems}

\index{calc\_en\_tanh() (in module tool\_create\_substrate)@\spxentry{calc\_en\_tanh()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_en_tanh}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_en\_tanh}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{ww}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on CM.

\sphinxAtStartPar
Substrate energy is modelled as a lattice of tanh\sphinxhyphen{}shaped wells.

\sphinxAtStartPar
See corresponding particle function for details on parameters.

\sphinxAtStartPar
Return total energy (scalar) force (2d vector) torque (scalar).

\end{fulllineitems}

\index{calc\_matrices\_bvect() (in module tool\_create\_substrate)@\spxentry{calc\_matrices\_bvect()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_matrices_bvect}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_matrices\_bvect}}}{\emph{\DUrole{n}{b1}}, \emph{\DUrole{n}{b2}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Metric matrices from primitive lattice vectors b1, b2.

\sphinxAtStartPar
Return 2x2 matrices to map to unit cell (u) and inverse (u\_inv), back to real space.

\end{fulllineitems}

\index{calc\_matrices\_square() (in module tool\_create\_substrate)@\spxentry{calc\_matrices\_square()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_matrices_square}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_matrices\_square}}}{\emph{\DUrole{n}{R}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Metric matrices of square lattice of spacing R.

\sphinxAtStartPar
Return 2x2 matrices to map to unit cell (u) and inverse (u\_inv), back to real space.

\end{fulllineitems}

\index{calc\_matrices\_triangle() (in module tool\_create\_substrate)@\spxentry{calc\_matrices\_triangle()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.calc_matrices_triangle}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{calc\_matrices\_triangle}}}{\emph{\DUrole{n}{R}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Metric matrices of triangular lattice of spacing R.

\sphinxAtStartPar
Return 2x2 matrices to map to unit cell (u) and inverse (u\_inv), back to real space.

\end{fulllineitems}

\index{gaussian() (in module tool\_create\_substrate)@\spxentry{gaussian()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.gaussian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{gaussian}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{mu}}, \emph{\DUrole{n}{sigma}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{get\_ks() (in module tool\_create\_substrate)@\spxentry{get\_ks()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.get_ks}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{get\_ks}}}{\emph{\DUrole{n}{R}}, \emph{\DUrole{n}{n}}, \emph{\DUrole{n}{c\_n}}, \emph{\DUrole{n}{alpha\_n}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute wave vectors k of interfering plane waves

\end{fulllineitems}

\index{particle\_en\_gaussian() (in module tool\_create\_substrate)@\spxentry{particle\_en\_gaussian()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.particle_en_gaussian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{particle\_en\_gaussian}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{sigma}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on each particle.

\sphinxAtStartPar
Substrate energy is modelled as a lattice of gaussian\sphinxhyphen{}shaped wells.

\sphinxAtStartPar
Inputs are:
\sphinxhyphen{} pos: position of particles in rigid cluster, as (N,2) array.
\sphinxhyphen{} pos\_torque: reference point (1,2 array) to compute the torque (usually CM).
\sphinxhyphen{} basis: list of position of the substrate basis (N,2 array).

\sphinxAtStartPar
Well specific inputs (usually passed as {\color{red}\bfseries{}*}en\_input):
\sphinxhyphen{} a, b: beginning and end of tempered region (W=0 for x\textgreater{}b).
\sphinxhyphen{} sigma: width of the gaussian.
\sphinxhyphen{} epsilon: depth of the well.
\sphinxhyphen{} u, u\_inv: matrices to map to subsrtate unit cell (see calc\_matrices\_bvect)

\sphinxAtStartPar
Returns (for each particle) energy (N array), force (N,2), torque (N)

\end{fulllineitems}

\index{particle\_en\_sin() (in module tool\_create\_substrate)@\spxentry{particle\_en\_sin()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.particle_en_sin}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{particle\_en\_sin}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{ks}}, \emph{\DUrole{n}{epsilon}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on each particle.

\sphinxAtStartPar
Substrate energy is modelled as sum of plane waves defined by the reciprocal vecotrs ks.

\sphinxAtStartPar
Inputs are:
\sphinxhyphen{} pos: position of particles in rigid cluster, as (N,2) array.
\sphinxhyphen{} pos\_torque: reference point (1,2 array) to compute the torque (usually CM).
\sphinxhyphen{} basis: list of position of the substrate basis (N,2 array).

\sphinxAtStartPar
Well specific inputs (usually passed as {\color{red}\bfseries{}*}en\_input):
\sphinxhyphen{} ks: list of wavevector generating the potential.
\sphinxhyphen{} epsilon: depth of the potential.

\sphinxAtStartPar
Returns (for each particle) energy (N array), force (N,2), torque (N)

\end{fulllineitems}

\index{particle\_en\_sin\_tri() (in module tool\_create\_substrate)@\spxentry{particle\_en\_sin\_tri()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.particle_en_sin_tri}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{particle\_en\_sin\_tri}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{R}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on each particle.

\sphinxAtStartPar
!!! Coefficients are for triangular lattice only !!!
Substrate energy is modelled as sum of three plane waves.

\end{fulllineitems}

\index{particle\_en\_tanh() (in module tool\_create\_substrate)@\spxentry{particle\_en\_tanh()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.particle_en_tanh}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{particle\_en\_tanh}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pos\_torque}}, \emph{\DUrole{n}{basis}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{ww}}, \emph{\DUrole{n}{epsilon}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{u\_inv}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Calculate energy, forces and torque on each particle.

\sphinxAtStartPar
Substrate energy is modelled as a lattice of tanh\sphinxhyphen{}shaped wells.

\sphinxAtStartPar
Inputs are:
\sphinxhyphen{} pos: position of particles in rigid cluster, as (N,2) array.
\sphinxhyphen{} pos\_torque: reference point (1,2 array) to compute the torque (usually CM).
\sphinxhyphen{} basis: list of position of the substrate basis (N,2 array).

\sphinxAtStartPar
Well specific inputs (usually passed as {\color{red}\bfseries{}*}en\_input):
\sphinxhyphen{} a, b: beginning and end of tanh well (W=\sphinxhyphen{}epsilon for r\textless{}a, W=0 for x\textgreater{}b).
\sphinxhyphen{} ww: shape factor for the tanh potential.
\sphinxhyphen{} epsilon: depth of the well.
\sphinxhyphen{} u, u\_inv: matrices to map to subsrtate unit cell (see calc\_matrices\_bvect)

\sphinxAtStartPar
Returns (for each particle) energy (N array), force (N,2), torque (N)

\end{fulllineitems}

\index{substrate\_from\_params() (in module tool\_create\_substrate)@\spxentry{substrate\_from\_params()}\spxextra{in module tool\_create\_substrate}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_substrate:tool_create_substrate.substrate_from_params}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_substrate.}}\sphinxbfcode{\sphinxupquote{substrate\_from\_params}}}{\emph{\DUrole{n}{params}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Initialise a substrate from a parameter dictionary (usually from JSON file)

\sphinxAtStartPar
Returns the functions computing the particle\sphinxhyphen{}wise and total energy, and the list of potential\sphinxhyphen{}specific paramters to pass to these functions.

\end{fulllineitems}


\sphinxstepscope


\subsubsection{Cluster}
\label{\detokenize{tool_create_cluster:module-tool_create_cluster}}\label{\detokenize{tool_create_cluster:cluster}}\label{\detokenize{tool_create_cluster::doc}}\index{module@\spxentry{module}!tool\_create\_cluster@\spxentry{tool\_create\_cluster}}\index{tool\_create\_cluster@\spxentry{tool\_create\_cluster}!module@\spxentry{module}}\index{add\_basis() (in module tool\_create\_cluster)@\spxentry{add\_basis()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.add_basis}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{add\_basis}}}{\emph{\DUrole{n}{lat\_pos}}, \emph{\DUrole{n}{basis}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Add a crystal basis to a simple Bravais lattice

\end{fulllineitems}

\index{calc\_cluster\_langevin() (in module tool\_create\_cluster)@\spxentry{calc\_cluster\_langevin()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.calc_cluster_langevin}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{calc\_cluster\_langevin}}}{\emph{\DUrole{n}{eta}}, \emph{\DUrole{n}{pos}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the effective translational and rotational damping acting on a CM of a cluster of N particles

\end{fulllineitems}

\index{cluster\_from\_params() (in module tool\_create\_cluster)@\spxentry{cluster\_from\_params()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.cluster_from_params}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{cluster\_from\_params}}}{\emph{\DUrole{n}{params}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create cluster from parameters in dictionary.

\sphinxAtStartPar
Return xy positions

\end{fulllineitems}

\index{cluster\_inhex\_Nl() (in module tool\_create\_cluster)@\spxentry{cluster\_inhex\_Nl()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.cluster_inhex_Nl}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{cluster\_inhex\_Nl}}}{\emph{\DUrole{n}{N1}}, \emph{\DUrole{n}{N2}}, \emph{\DUrole{n}{a1=array({[}4.45}}, \emph{\DUrole{n}{0.  {]})}}, \emph{\DUrole{n}{a2=array({[}\sphinxhyphen{}2.225}}, \emph{\DUrole{n}{3.85381305{]})}}, \emph{\DUrole{n}{clgeom\_fname=\textquotesingle{}input\_pos.hex\textquotesingle{}}}, \emph{\DUrole{n}{cluster\_f=\textless{}function create\_cluster\_circle\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create a cluster from lattice details (equivalent to .hex file) and specific shape function.

\sphinxAtStartPar
The .hex file will be created and removed using tempfile.
Returns only xy positions.

\sphinxAtStartPar
Default values relate to Xin/EP colloids {[}Nat. Phys 2019, PRE 2021{]} and circular shape

\end{fulllineitems}

\index{cluster\_poly() (in module tool\_create\_cluster)@\spxentry{cluster\_poly()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.cluster_poly}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{cluster\_poly}}}{\emph{\DUrole{n}{polygon}}, \emph{\DUrole{n}{params}}, \emph{\DUrole{n}{direction}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Use a polygon (shapely object) to mask a lattice (defined in params).

\sphinxAtStartPar
Direction = 0: select the interior of the polygon (use bounds of polygon to define lattice big enough for mask)
Direction = 1: select the exterior of the polygon (up to the N1 N2 in params)

\sphinxAtStartPar
Return xy pos

\end{fulllineitems}

\index{create\_cluster() (in module tool\_create\_cluster)@\spxentry{create\_cluster()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster}}}{\emph{\DUrole{n}{input\_cluster}}, \emph{\DUrole{n}{angle}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create clusters taking as input the two primitive vectors a1 and a2 and the indices of lattice points.
Put center of mass in zero.

\end{fulllineitems}

\index{create\_cluster\_circle() (in module tool\_create\_cluster)@\spxentry{create\_cluster\_circle()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster_circle}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster\_circle}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Circle cluster

\sphinxAtStartPar
The 6 dimensions are for backward compatibility with EP.

\end{fulllineitems}

\index{create\_cluster\_hex() (in module tool\_create\_cluster)@\spxentry{create\_cluster\_hex()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster_hex}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster\_hex}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Hexagonal cluster

\sphinxAtStartPar
The 6 dimensions are for backward compatibility with EP.

\end{fulllineitems}

\index{create\_cluster\_rect() (in module tool\_create\_cluster)@\spxentry{create\_cluster\_rect()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster_rect}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster\_rect}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Rectangular cluster

\sphinxAtStartPar
The 6 dimensions are for backward compatibility with EP.

\end{fulllineitems}

\index{create\_cluster\_special() (in module tool\_create\_cluster)@\spxentry{create\_cluster\_special()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster_special}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster\_special}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Special\sphinxhyphen{}parall cluster. See paper on XXX.

\sphinxAtStartPar
The 6 dimensions are for backward compatibility with EP.

\end{fulllineitems}

\index{create\_cluster\_tri() (in module tool\_create\_cluster)@\spxentry{create\_cluster\_tri()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_cluster_tri}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_cluster\_tri}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{X0=0}}, \emph{\DUrole{n}{Y0=0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Triangular cluster

\sphinxAtStartPar
The 6 dimensions are for backward compatibility with EP.

\end{fulllineitems}

\index{create\_input\_hex() (in module tool\_create\_cluster)@\spxentry{create\_input\_hex()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.create_input_hex}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{create\_input\_hex}}}{\emph{\DUrole{n}{N1}}, \emph{\DUrole{n}{N2}}, \emph{\DUrole{n}{clgeom\_fname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}in.hex\textquotesingle{}}}, \emph{\DUrole{n}{a1}\DUrole{o}{=}\DUrole{default_value}{array({[}4.45, 0.0{]})}}, \emph{\DUrole{n}{a2}\DUrole{o}{=}\DUrole{default_value}{array({[}\sphinxhyphen{}2.225, 3.85381305{]})}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create input file in EP .hex format

\sphinxAtStartPar
Cluster is created from Bravais lattice a1 a2 with N1 repetition along a1 and N2 repetitions along N2.
Default is Xin colloids: triangular with spacing 4.45

\end{fulllineitems}

\index{get\_poly() (in module tool\_create\_cluster)@\spxentry{get\_poly()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.get_poly}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{get\_poly}}}{\emph{\DUrole{n}{points}}, \emph{\DUrole{n}{scale}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{tho}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{{[}0, 0{]}}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{cm}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Get a polygon (Shapely obejct) from a set of points.

\sphinxAtStartPar
Optinally rotate, scale and shfit

\end{fulllineitems}

\index{get\_rotomatr() (in module tool\_create\_cluster)@\spxentry{get\_rotomatr()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.get_rotomatr}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{get\_rotomatr}}}{\emph{\DUrole{n}{angle}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Get ACW rotation matrix of an angle {[}degree{]}

\end{fulllineitems}

\index{load\_cluster() (in module tool\_create\_cluster)@\spxentry{load\_cluster()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.load_cluster}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{load\_cluster}}}{\emph{\DUrole{n}{input\_hex}}, \emph{\DUrole{n}{angle}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{center}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Load cluster form numpy file data. Optionally adjust CM and rotate.

\end{fulllineitems}

\index{load\_input\_hex() (in module tool\_create\_cluster)@\spxentry{load\_input\_hex()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.load_input_hex}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{load\_input\_hex}}}{\emph{\DUrole{n}{instream}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Load .hex file defining lattice and size

\end{fulllineitems}

\index{params\_from\_ASE() (in module tool\_create\_cluster)@\spxentry{params\_from\_ASE()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.params_from_ASE}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{params\_from\_ASE}}}{\emph{\DUrole{n}{ase\_geom}}, \emph{\DUrole{n}{cut\_z}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create JSON parameters to create clusters from ASE Atoms object.

\sphinxAtStartPar
Assume this is already a 2D surface oriented along z to extract 2x2 matrix:
From:
\begin{quote}

\sphinxAtStartPar
a b 0
c d 0
0 0 1
\end{quote}
\begin{description}
\sphinxlineitem{Take:}
\sphinxAtStartPar
a b
c d

\end{description}

\sphinxAtStartPar
Positions are flattend out: (x,y) from (x,y,z)

\sphinxAtStartPar
Return parameters dictionary and list of z coordinates considered

\end{fulllineitems}

\index{params\_from\_poscar() (in module tool\_create\_cluster)@\spxentry{params\_from\_poscar()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.params_from_poscar}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{params\_from\_poscar}}}{\emph{\DUrole{n}{poscar\_fname}}, \emph{\DUrole{n}{cut\_z}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Create JSON parameters to create clusters from POSCAR file.

\sphinxAtStartPar
Use ASE to read.

\sphinxAtStartPar
Return parameters file.

\end{fulllineitems}

\index{rotate() (in module tool\_create\_cluster)@\spxentry{rotate()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.rotate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{rotate}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{angle}}, \emph{\DUrole{n}{c}\DUrole{o}{=}\DUrole{default_value}{{[}0, 0{]}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Rotate positions pos of angle {[}degree{]} with respect to center c (default 0,0)

\end{fulllineitems}

\index{save\_xyz() (in module tool\_create\_cluster)@\spxentry{save\_xyz()}\spxextra{in module tool\_create\_cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{tool_create_cluster:tool_create_cluster.save_xyz}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{tool\_create\_cluster.}}\sphinxbfcode{\sphinxupquote{save\_xyz}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{outfname}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cluster.xyz\textquotesingle{}}}, \emph{\DUrole{n}{elem}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}X\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Save cluster as xyz in given file (default ‘cluster.xyz’)

\end{fulllineitems}


\sphinxstepscope


\subsubsection{String method}
\label{\detokenize{string_method:module-string_method}}\label{\detokenize{string_method:string-method}}\label{\detokenize{string_method::doc}}\index{module@\spxentry{module}!string\_method@\spxentry{string\_method}}\index{string\_method@\spxentry{string\_method}!module@\spxentry{module}}\index{Path (class in string\_method)@\spxentry{Path}\spxextra{class in string\_method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.Path}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{string\_method.}}\sphinxbfcode{\sphinxupquote{Path}}}{\emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{N}}, \emph{\DUrole{n}{fix\_ends}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}
\index{eulerArc() (string\_method.Path method)@\spxentry{eulerArc()}\spxextra{string\_method.Path method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.Path.eulerArc}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eulerArc}}}{\emph{\DUrole{n}{potential}}, \emph{\DUrole{n}{dt}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}07}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Euler method to integrate dynamics.

\end{fulllineitems}

\index{reparametrizeArc() (string\_method.Path method)@\spxentry{reparametrizeArc()}\spxextra{string\_method.Path method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.Path.reparametrizeArc}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reparametrizeArc}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Equal arc parameterisation of the path.

\end{fulllineitems}


\end{fulllineitems}

\index{PotentialPathAnalyt (class in string\_method)@\spxentry{PotentialPathAnalyt}\spxextra{class in string\_method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.PotentialPathAnalyt}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{string\_method.}}\sphinxbfcode{\sphinxupquote{PotentialPathAnalyt}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{en\_f}}, \emph{\DUrole{n}{en\_in}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}
\index{grad() (string\_method.PotentialPathAnalyt method)@\spxentry{grad()}\spxextra{string\_method.PotentialPathAnalyt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.PotentialPathAnalyt.grad}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Mathematical form of gradient (dV/dx, dV/dy) along the path gamma.

\end{fulllineitems}

\index{total() (string\_method.PotentialPathAnalyt method)@\spxentry{total()}\spxextra{string\_method.PotentialPathAnalyt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.PotentialPathAnalyt.total}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{total}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Mathematical form of the total potential function V along the
path gamma.

\end{fulllineitems}

\index{update() (string\_method.PotentialPathAnalyt method)@\spxentry{update()}\spxextra{string\_method.PotentialPathAnalyt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{string_method:string_method.PotentialPathAnalyt.update}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update}}}{\emph{\DUrole{n}{path}}}{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}



\subsection{Static}
\label{\detokenize{modules:static}}
\sphinxstepscope


\subsubsection{Static Translation}
\label{\detokenize{static_trasl_map:module-static_trasl_map}}\label{\detokenize{static_trasl_map:static-translation}}\label{\detokenize{static_trasl_map::doc}}\index{module@\spxentry{module}!static\_trasl\_map@\spxentry{static\_trasl\_map}}\index{static\_trasl\_map@\spxentry{static\_trasl\_map}!module@\spxentry{module}}\index{static\_traslmap() (in module static\_trasl\_map)@\spxentry{static\_traslmap()}\spxextra{in module static\_trasl\_map}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{static_trasl_map:static_trasl_map.static_traslmap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{static\_trasl\_map.}}\sphinxbfcode{\sphinxupquote{static\_traslmap}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{inputs}}, \emph{\DUrole{n}{calc\_en\_f}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_propagate}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the energy of a rigid cluster as a function of CM position, at fixed orientation.

\sphinxAtStartPar
Inputs contains the details of the system, along with the unit cell of the substrate (S) and the fractional range of nbin translation to explore along each lattice direction (S{[}0{]}, S{[}1{]}).

\sphinxAtStartPar
Return a Nx6 array with xcm, ycm, e\_pot, forces{[}0{]}, forces{[}1{]}, torque

\end{fulllineitems}


\sphinxstepscope


\subsubsection{Static Rotation}
\label{\detokenize{static_roto_map:module-static_roto_map}}\label{\detokenize{static_roto_map:static-rotation}}\label{\detokenize{static_roto_map::doc}}\index{module@\spxentry{module}!static\_roto\_map@\spxentry{static\_roto\_map}}\index{static\_roto\_map@\spxentry{static\_roto\_map}!module@\spxentry{module}}\index{static\_rotomap() (in module static\_roto\_map)@\spxentry{static\_rotomap()}\spxextra{in module static\_roto\_map}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{static_roto_map:static_roto_map.static_rotomap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{static\_roto\_map.}}\sphinxbfcode{\sphinxupquote{static\_rotomap}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{inputs}}, \emph{\DUrole{n}{calc\_en\_f}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_propagate}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the energy of a rigid cluster as a function of orientation, at fixed position.

\sphinxAtStartPar
Inputs contains the details of the system, along with the range of N angles to explore.

\sphinxAtStartPar
Return a Nx5 array with theta, e\_pot, forces{[}0{]}, forces{[}1{]}, torque

\end{fulllineitems}


\sphinxstepscope


\subsubsection{Transition state barrier}
\label{\detokenize{static_barrier_string:module-static_barrier_string}}\label{\detokenize{static_barrier_string:transition-state-barrier}}\label{\detokenize{static_barrier_string::doc}}\index{module@\spxentry{module}!static\_barrier\_string@\spxentry{static\_barrier\_string}}\index{static\_barrier\_string@\spxentry{static\_barrier\_string}!module@\spxentry{module}}\index{static\_barrier() (in module static\_barrier\_string)@\spxentry{static\_barrier()}\spxextra{in module static\_barrier\_string}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{static_barrier_string:static_barrier_string.static_barrier}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{static\_barrier\_string.}}\sphinxbfcode{\sphinxupquote{static\_barrier}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{inputs}}, \emph{\DUrole{n}{calc\_en\_f}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_propagate}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the transition state barrier of a rigid cluster between two points of the substrate.

\sphinxAtStartPar
The barrier is computed using the string algorithm {[}DOI: 10.1063/1.2720838{]}.

\sphinxAtStartPar
Inputs:
\sphinxhyphen{} pos: position of particles in rigid cluster
\sphinxhyphen{} inputs: dictionary defining the syste. Must contain the start (p0) and end (p1) of the initial path. Optionally, the number of points in the string (Npt=100) and number of iterations (Nsteps=3000)

\sphinxAtStartPar
Returns the positions of the relaxed path, along with energy, force and torque evaluated along it.

\end{fulllineitems}


\sphinxstepscope


\subsubsection{Static Rotation and Translation}
\label{\detokenize{static_rototrasl_map:module-static_rototrasl_map}}\label{\detokenize{static_rototrasl_map:static-rotation-and-translation}}\label{\detokenize{static_rototrasl_map::doc}}\index{module@\spxentry{module}!static\_rototrasl\_map@\spxentry{static\_rototrasl\_map}}\index{static\_rototrasl\_map@\spxentry{static\_rototrasl\_map}!module@\spxentry{module}}\index{static\_rototraslmap() (in module static\_rototrasl\_map)@\spxentry{static\_rototraslmap()}\spxextra{in module static\_rototrasl\_map}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{static_rototrasl_map:static_rototrasl_map.static_rototraslmap}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{static\_rototrasl\_map.}}\sphinxbfcode{\sphinxupquote{static\_rototraslmap}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{inputs}}, \emph{\DUrole{n}{calc\_en\_f}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_propagate}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{debug}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Compute the energy of a rigid cluster as a function of CM position and orientation theta.

\sphinxAtStartPar
Inputs contains the details of the system, along with the unit cell of the substrate (S) and the fractional range of nbin translation to explore along each lattice direction (S{[}0{]}, S{[}1{]}), and range of orientations.

\sphinxAtStartPar
Return a Nx7 array with theta, xcm, ycm, e\_pot, forces{[}0{]}, forces{[}1{]}, torque

\end{fulllineitems}



\subsection{Dynamics}
\label{\detokenize{modules:dynamics}}
\sphinxstepscope


\subsubsection{Molecular Dynamics of rigid cluster}
\label{\detokenize{md_rigid_rototrasl:module-MD_rigid_rototrasl}}\label{\detokenize{md_rigid_rototrasl:molecular-dynamics-of-rigid-cluster}}\label{\detokenize{md_rigid_rototrasl::doc}}\index{module@\spxentry{module}!MD\_rigid\_rototrasl@\spxentry{MD\_rigid\_rototrasl}}\index{MD\_rigid\_rototrasl@\spxentry{MD\_rigid\_rototrasl}!module@\spxentry{module}}\index{MD\_rigid() (in module MD\_rigid\_rototrasl)@\spxentry{MD\_rigid()}\spxextra{in module MD\_rigid\_rototrasl}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{md_rigid_rototrasl:MD_rigid_rototrasl.MD_rigid}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MD\_rigid\_rototrasl.}}\sphinxbfcode{\sphinxupquote{MD\_rigid}}}{\emph{\DUrole{n}{inputs}}, \emph{\DUrole{n}{outstream=\textless{}\_io.TextIOWrapper name=\textquotesingle{}\textless{}stdout\textgreater{}\textquotesingle{} mode=\textquotesingle{}w\textquotesingle{} encoding=\textquotesingle{}UTF\sphinxhyphen{}8\textquotesingle{}\textgreater{}}}, \emph{\DUrole{n}{name=None}}, \emph{\DUrole{n}{log\_propagate=False}}, \emph{\DUrole{n}{debug=False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Overdamped (1st order differential equaltion) Langevin Molecular Dynamics of rigid cluster over a substrate.

\sphinxAtStartPar
Input parameters are passaed as directly as dictionary or read from a JSON file (if inputs is a string).
Position of particles in cluster is given as .hex or .npy filename.
Info about run are written in name+’info.json’

\sphinxAtStartPar
MD output is printed on sys stdout.

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{MD\_rigid\_rototrasl}\sphinxstyleindexpageref{md_rigid_rototrasl:\detokenize{module-MD_rigid_rototrasl}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{static\_barrier\_string}\sphinxstyleindexpageref{static_barrier_string:\detokenize{module-static_barrier_string}}
\item\relax\sphinxstyleindexentry{static\_roto\_map}\sphinxstyleindexpageref{static_roto_map:\detokenize{module-static_roto_map}}
\item\relax\sphinxstyleindexentry{static\_rototrasl\_map}\sphinxstyleindexpageref{static_rototrasl_map:\detokenize{module-static_rototrasl_map}}
\item\relax\sphinxstyleindexentry{static\_trasl\_map}\sphinxstyleindexpageref{static_trasl_map:\detokenize{module-static_trasl_map}}
\item\relax\sphinxstyleindexentry{string\_method}\sphinxstyleindexpageref{string_method:\detokenize{module-string_method}}
\indexspace
\bigletter{t}
\item\relax\sphinxstyleindexentry{tool\_create\_cluster}\sphinxstyleindexpageref{tool_create_cluster:\detokenize{module-tool_create_cluster}}
\item\relax\sphinxstyleindexentry{tool\_create\_substrate}\sphinxstyleindexpageref{tool_create_substrate:\detokenize{module-tool_create_substrate}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}